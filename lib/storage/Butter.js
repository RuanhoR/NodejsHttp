"use strict";async function all(t){return new Promise(async(e,r)=>{let i;await fs.readdir(t).then(t=>i=t),e(i)})}async function isDir(t){try{return(await fs.stat(t)).isDirectory()}catch(t){if("ENOENT"===t.code)return!1;throw t}}function gun(t){return zlib.gunzipSync(t).toString()}async function del(t,e,r){return new Promise(async(i,n)=>{try{let n;0,r?await fs.rm(`${t}/${e}/.${r}`,{force:!0},t=>{n=t}):await fs.rm(`${t}/${e}`,{recursive:!0,force:!0},t=>{n=t}),i({code:n?-1:200,msg:n?n.message:"SUCCESS"})}catch(t){i({code:-1,msg:t.message})}})}async function get(t,e){return new Promise(async(r,i)=>{try{const i=`${t}/${e}`;let n;await fs.readdir(i).then(t=>n=t);let s=new Map;for(let t of n){const e=`${i}/${t}`,r=await fs.readFile(e);try{s.set(t,gun(r))}catch(e){s.set(t,r.toString())}}r(s)}catch(t){r(t)}})}async function add(t,e,r){return new Promise((i,n)=>{try{if(file_lock.set(e,!0),"string"!=typeof t||"string"!=typeof e)throw new Error("INVALID_PATH_OR_NAME");if(r instanceof Map&&Object.getPrototypeOf(r)===Map.prototype)throw new Error("DATA_MUST_BE_MAP");const n=`${t}/${e}`;isDir(n)||createDir(n),Array.from(r.keys()).map(async t=>{const e=String(r.get(t)),i=e.length>50?await zipText(`${e}`):e;await writeFile(`${n}/${t}`,i)}),file_lock.set(e,!1),i({code:200,msg:"SUCCESS"})}catch(t){i({code:-1,msg:t.message})}})}async function createDir(t){try{return await fs.mkdir(t,{recursive:!0}),!0}catch(t){if("EEXIST"===t.code)return!0;throw t}}async function writeFile(t,e){try{const r=t.substring(0,t.lastIndexOf("/"));return await isDir(r)||await createDir(r),await fs.writeFile(t,e),!0}catch(t){throw new Error(`FILE_WRITE_ERROR: ${t.message}`)}}async function zipText(t){try{return await gzip(Buffer.from(String(t)),{level:9})}catch(t){throw new Error(`GZIP_FAILED: ${t.message}`)}}const fs=require("fs").promises,zlib=require("zlib"),{promisify:promisify}=require("util"),gzip=promisify(zlib.gzip);module.exports={all:all,get:get,add:add,del:del};